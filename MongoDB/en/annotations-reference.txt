In this chapter a reference of every Doctrine 2 ODM Annotation is given with short explanations on their context and usage.

++ Index

* [@Bin](#ann_bin)
* [@BinCustom](#ann_bin_custom)
* [@BinFunc](#ann_bin_func)
* [@BinMD5](#ann_bin_md5)
* [@BinUUID](#ann_bin_uuid)
* [@Boolean](#ann_boolean)
* [@Date](#ann_date)
* [@Document](#ann_document)
* [@DiscriminatorField](#ann_discriminator_field)
* [@DiscriminatorMap](#ann_discriminator_map)
* [@EmbedMany](#ann_embed_many)
* [@EmbedOne](#ann_embed_one)
* [@Field](#ann_field)
* [@File](#ann_file)
* [@Float](#ann_float)
* [@HasLifecycleCallbacks](#ann_has_lifecycle_callbacks)
* [@Id](#ann_id)
* [@Index](#ann_index)
* [@Inheritance](#ann_inheritance)
* [@InheritanceType](#ann_inheritance_type)
* [@Int](#ann_int)
* [@Key](#ann_key)
* [@PostLoad](#ann_post_load)
* [@PostPersist](#ann_post_persist)
* [@PostRemove](#ann_post_remove)
* [@PostUpdate](#ann_post_update)
* [@PrePersist](#ann_pre_persist)
* [@PreRemove](#ann_pre_remove)
* [@PreUpdate](#ann_pre_update)
* [@ReferenceOne](#ann_reference_one)
* [@ReferenceMany](#ann_reference_many)
* [@String](#ann_string)
* [@Timestamp](#ann_timestamp)

++ Reference

<a name="ann_bin"></a>
+++ @Bin



<a name="ann_field"></a>
+++ @Field

Marks an annotated instance variable as "persistent". It has to be inside the instance variables PHP DocBlock comment.
Any value hold inside this variable will be saved to and loaded from the document store as part of the lifecycle of the instance variables document-class.

Required attributes:

* type - Name of the Doctrine ODM Type which is converted between PHP and Database representation.

Optional attributes:

* name - By default the property name is used for the mongodb field name also, however the 'name' attribute allows you to specify the field name.

Examples:

    /**
     * @Field(type="string")
     */
    protected $username;

    /**
     * @Field(type="string" name="origin")
     */
    protected $country;

    /**
     * @Column(type="float")
     */
    protected $height;

<a name="ann_discriminator_field"></a>
+++ @DiscrimnatorField

This annotation is a required annotation for the topmost/super class of an inheritance hierachy. It specifies
the details of the field which saves the name of the class, which the document is actually instantiated as.

Required attributes:

* fieldName - The field name of the discriminator. This name is also used during Array hydration as key to specify the class-name.

<a name="ann_discriminator_map"></a>
+++ @DiscriminatorMap

The discrimnator map is a required annotation on the top-most/super class in an inheritance hierachy. It takes
an array as only argument which defines which class should be saved under which name in the database. Keys
are the database value and values are the classes, either as fully- or as unqualified class names depending
if the classes are in the namespace or not.

    /**
     * @Document
     * @InheritanceType("SINGLE_COLLECTION")
     * @DiscriminatorField(fieldName="discr")
     * @DiscriminatorMap({"person" = "Person", "employee" = "Employee"})
     */
    class Person
    {
        /**
         * @Field(type="string")
         */
        private $discr;
        // ...
    }


<a name="ann_document"></a>
+++ @Document

Required annotation to mark a PHP class as Document. Doctrine ODM manages the persistence of all classes marked as document.

Optional attributes:

* db - Document Manager uses the default mongo db database, unless it has database name to use set, this value can be specified to override database to use on per document basis.
* collection - By default collection name is extracted from the document's class name, but this attribute can be used to override.
* repositoryClass - Specifies custom repository class to use when .

Example:

    /**
     * @Entity(repositoryClass="MyProject\UserRepository")
     */
    class User
    {
        //...
    }

<a name="ann_generatedvalue"></a>
+++ @GeneratedValue

Specifies which strategy is used for identifier generation for an instance variable which is annotated by [@Id](#ann_id).
This annotation is optional and only has meaning when used in conjunction with @Id.

If this annotation is not specified with @Id the NONE strategy is used as default.

Required attributes:

* strategy - Set the name of the identifier generation strategy. Valid values are AUTO, SEQUENCE, TABLE, IDENTITY and NONE.

Example:

    /**
     * @Id
     * @Column(type="integer")
     * @generatedValue(strategy="IDENTITY")
     */
    protected $id = null;

<a name="ann_haslifecyclecallbacks"></a>
+++ @HasLifecycleCallbacks

Annotation which has to be set on the entity-class PHP DocBlock to notify Doctrine that this entity has entity life-cycle
callback annotations set on at least one of its methods. Using @PostLoad, @PrePersist, @PostPersist, @PreRemove, @PostRemove,
@PreUpdate or @PostUpdate without this marker annotation will make Doctrine ignore the callbacks.

Example:

    /**
     * @Entity
     * @HasLifecycleCallbacks
     */
    class User
    {
        /**
         * @PostPersist
         */
        public function sendOptinMail() {}
    }

<a name="ann_indexes"></a>
+++ @Index

Annotation is used inside the [@Table](#ann_table) annotation on the entity-class level. It allows to hint the
SchemaTool to generate a database index on the specified table columns. It only has meaning in the SchemaTool
schema generation context.

Required attributes:

* name - Name of the Index
* columns - Array of columns.

Example:

    /**
     * @Entity
     * @Table(name="ecommerce_products",indexes={@index(name="search_idx", columns={"name", "email"})})
     */
    class ECommerceProduct
    {
    }

<a name="ann_id"></a>
+++ @Id

The annotated instance variable will be marked as entity identifier, the primary key in the database.
This annotation is a marker only and has no required or optional attributes. For entites that have multiple
identifier columns each column has to be marked with @Id.

Example:

    /**
     * @Id
     * @Column(type="integer")
     */
    protected $id = null;

<a name="ann_inheritancetype"></a>
+++ @InheritanceType

In an inheritance hierachy you have to use this annotation on the topmost/super class to define which
strategy should be used for inheritance. Currently Single Table and Class Table Inheritance are supported.

This annotation has always been used in conjunction with the [@DiscriminatorMap](#ann_discriminatormap) and
[@DiscriminatorColumn](#ann_discriminatorcolumn) annotations.

Examples:

    /**
     * @Entity
     * @InheritanceType("SINGLE_TABLE")
     * @DiscriminatorColumn(name="discr", type="string")
     * @DiscriminatorMap({"person" = "Person", "employee" = "Employee"})
     */
    class Person
    {
        // ...
    }

    /**
     * @Entity
     * @InheritanceType("JOINED")
     * @DiscriminatorColumn(name="discr", type="string")
     * @DiscriminatorMap({"person" = "Person", "employee" = "Employee"})
     */
    class Person
    {
        // ...
    }

<a name="ann_joincolumn"></a>
+++ @JoinColumn

This annotation is used in the context of relations in [@ManyToOne](#ann_manytoone), [@OneToOne](#ann_onetoone) fields
and in the Context of [@JoinTable](#ann_jointable) nested inside a @ManyToMany. This annotation is not required.
If its not specified the attributes *name* and *referencedColumnName* are infered from the table and primary key names.

Required attributes:

* name - Column name that holds the foreign key identifier for this relation. In the context of @JoinTable it specifies the column name in the join table.
* referencedColumnName - Name of the primary key identifier that is used for joining of this relation.

Optional attributes:

* unique - Determines if this relation exclusive between the affected entities and should be enforced so on the database constraint level. Defaults to false.
* nullable - Determine if the related entity is required, or if null is an allowed state for the relation. Defaults to true.
* onDelete - Cascade Action (Database-level)
* onUpdate - Cascade Action (Database-level)
* columnDefinition - DDL SQL snippet that starts after the column name and specificies the complete (non-portable!) column definition. This attribute allows to make use of advanced RMDBS features. Using this attribute on @JoinColumn is necessary if you need slightly different column definitions for joining columns, for example regarding NULL/NOT NULL defaults. However by default a "columnDefinition" attribute on [@Column](#ann_column) also sets the related @JoinColumn's columnDefinition. This is necessary to make foreign keys work.

Example:

    /**
     * @OneToOne(targetEntity="Customer")
     * @JoinColumn(name="customer_id", referencedColumnName="id")
     */
    private $customer;

<a name="ann_joincolumns"></a>
+++ @JoinColumns

An array of @JoinColumn annotations for a [@ManyToOne](#ann_manytoone) or [@OneToOne](#ann_onetoone) relation
with an entity that has multiple identifiers.

<a name="ann_jointable"></a>
+++ @JoinTable

Using [@OneToMany](#ann_onetomany) or [@ManyToMany](#ann_manytomany) on the owning side of the relation requires to specifiy
the @JoinTable annotation which describes the details of the database join table. If you do not specify @JoinTable on
these relations reasonable mapping defaults apply using the affected table and the column names.

Required attributes:

* name - Database name of the join-table
* joinColumns - An array of @JoinColumn annotations describing the join-relation between the owning entites table and the join table.
* inverseJoinColumns - An array of @JoinColumn annotations describing the join-relation between the inverse entities table and the join table.

Optional attributes:

* schema - Database schema name of this table.

Example:

    /**
     * @ManyToMany(targetEntity="Phonenumber")
     * @JoinTable(name="users_phonenumbers",
     *      joinColumns={@JoinColumn(name="user_id", referencedColumnName="id")},
     *      inverseJoinColumns={@JoinColumn(name="phonenumber_id", referencedColumnName="id", unique=true)}
     * )
     */
    public $phonenumbers;

<a name="ann_manytoone"></a>
+++ @ManyToOne

Defines that the annotated instance variable holds a reference that describes a many-to-one relationship between two entities.

Required attributes:

* targetEntity - FQCN of the referenced target entity. Can be the unqualified class name if both classes are in the same namespace.

Optional attributes:

* cascade - Cascade Option
* fetch - One of LAZY or EAGER

Example:

    /**
     * @ManyToOne(targetEntity="Cart", cascade="ALL", fetch="EAGER")
     */
    private $cart;

<a name="ann_manytomany"></a>
+++ @ManyToMany

Defines an instance variable holds a many-to-many relationship between two entities. [@JoinTable](#ann_jointable)
is an additional, optional annotation that has reasonable default configuration values using the table
and names of the two related entities.

Required attributes:

* targetEntity - FQCN of the referenced target entity. Can be the unqualified class name if both classes are in the same namespace.

Optional attributes:

* mappedBy - This option specifies the property name on the targetEntity that is the owning side of this relation. Its a required attribute for the inverse side of a relationship.
* cascade - Cascade Option
* fetch - One of LAZY or EAGER

Example:

    /**
     * Owning Side
     *
     * @ManyToMany(targetEntity="Group")
     * @JoinTable(name="user_groups",
     *      joinColumns={@JoinColumn(name="user_id", referencedColumnName="id")},
     *      inverseJoinColumns={@JoinColumn(name="group_id", referencedColumnName="id")}
     *      )
     */
    private $groups;

    /**
     * Inverse Side
     *
     * @ManyToMany(targetEntity="User", mappedBy="groups")
     */
    private $features;

<a name="ann_mappedsuperclass"></a>
+++ @MappedSuperclass

An mapped superclass is an abstract or concrete class that provides persistent entity state and mapping information
for its subclasses, but which is not itself an entity. This annotation is specified on the Class docblock
and has no additional attributes.

The @MappedSuperclass annotation cannot be used in conjunction with @Entity. See the Inheritance Mapping
section for [more details on the restrictions of mapped superclasses](/../inheritance-mapping#mapped-superclasses).

<a name="ann_onetoone"></a>
+++ @OnetoOne

The @OneToOne annotation works almost exactly as the [@ManyToOne](#ann_manytoone) with one additional option
that can be specified. The configuration defaults for [@JoinColumn](#ann_joincolumn) using the target entity table and primary key column names
apply here too.

Required attributes:

* targetEntity - FQCN of the referenced target entity. Can be the unqualified class name if both classes are in the same namespace.

Optional attributes:

* cascade - Cascade Option
* fetch - One of LAZY or EAGER
* orphanRemoval - Boolean that specifies if orphans, inverse OneToOne entities that are not connected to any
owning instance, should be removed by Doctrine. Defaults to false.

<a name="ann_onetomany"></a>
+++ @OneToMany

<a name="ann_orderby"></a>
+++ @OrderBy

Optional annotation that can be specified with a [@ManyToMany](#ann_manytomany) or [@OneToMany](#ann_onetomany)
annotation to specify by which criteria the collection should be retrieved from the database by using an ORDER BY
clause.

This annotation requires a single non-attributed value with an DQL snippet:

Example:

    /**
     * @ManyToMany(targetEntity="Group")
     * @OrderBy({"name" = "ASC"})
     */
    private $groups;

The DQL Snippet in OrderBy is only allowed to consist of unqualified,
unquoted field names and of an optional ASC/DESC positional statement.
Multiple Fields are separated by a comma (,). The referenced field
names have to exist on the `targetEntity` class of the `@ManyToMany` or
`@OneToMany` annotation.

<a name="ann_postload"></a>
+++ @PostLoad

Marks a method on the entity to be called as a @PostLoad event. Only works with @HasLifecycleCallbacks in the entity class PHP DocBlock.

<a name="ann_postpersist"></a>
+++ @PostPersist

Marks a method on the entity to be called as a @PostPersist event. Only works with @HasLifecycleCallbacks in the entity class PHP DocBlock.

<a name="ann_postremove"></a>
+++ @PostRemove

Marks a method on the entity to be called as a @PostRemove event. Only works with @HasLifecycleCallbacks in the entity class PHP DocBlock.

<a name="ann_postupdate"></a>
+++ @PostUpdate

Marks a method on the entity to be called as a @PostUpdate event. Only works with @HasLifecycleCallbacks in the entity class PHP DocBlock.

<a name="ann_prepersist"></a>
+++ @PrePersist

Marks a method on the entity to be called as a @PrePersist event. Only works with @HasLifecycleCallbacks in the entity class PHP DocBlock.

<a name="ann_preremove"></a>
+++ @PreRemove

Marks a method on the entity to be called as a @PreRemove event. Only works with @HasLifecycleCallbacks in the entity class PHP DocBlock.

<a name="ann_preupdate"></a>
+++ @PreUpdate

Marks a method on the entity to be called as a @PreUpdate event. Only works with @HasLifecycleCallbacks in the entity class PHP DocBlock.

<a name="ann_sequencegenerator"></a>
+++ @SequenceGenerator

For the use with @generatedValue(strategy="SEQUENCE") this annotation allows to specifiy details about the sequence,
such as the increment size and initial values of the sequence.

Required attributes:

* sequenceName - Name of the sequence

Optional attributes:

* allocationSize - Increment the sequence by the allocation size when its fetched. A value larger than 1 allows to optimize for scenarios where you create more than one new entity per request. Defaults to 10
* initialValue - Where does the sequence start, defaults to 1.

Example:

    /**
     * @Id
     * @GeneratedValue(strategy="SEQUENCE")
     * @Column(type="integer")
     * @SequenceGenerator(sequenceName="tablename_seq", initialValue=1, allocationSize=100)
     */
    protected $id = null;

<a name="ann_table"></a>
+++ @Table

Annotation describes the table an entity is persisted in. It is placed on the entity-class PHP DocBlock and is optional.
If it is not specified the table name will default to the entities unqualified classname.

Required attributes:

* name - Name of the table

Optional attributes:

* schema - Database schema name of this table.
* indexes - Array of @Index annotations
* uniqueConstraints - Array of @UniqueConstraint annotations.

Example:

    /**
     * @Entity
     * @Table(name="user",
     *      uniqueConstraints={@UniqueConstraint(name="user_unique",columns={"username"})},
     *      indexes={@Index(name="user_idx", columns={"email"})}
     * )
     */
    class User { }

<a name="ann_uniqueconstraint"></a>
+++ @UniqueConstraint

Annotation is used inside the [@Table](#ann_table) annotation on the entity-class level. It allows to hint the
SchemaTool to generate a database unique constraint on the specified table columns. It only has meaning in the SchemaTool
schema generation context.

Required attributes:

* name - Name of the Index
* columns - Array of columns.

Example:

    /**
     * @Entity
     * @Table(name="ecommerce_products",uniqueConstraints={@UniqueConstraint(name="search_idx", columns={"name", "email"})})
     */
    class ECommerceProduct
    {
    }

<a name="ann_version"></a>
+++ @Version

Marker annotation that defines a specified column as version attribute used in an optimistic locking scenario.
It only works on [@Column](#ann_column) annotations that have the type integer or datetime.

Example:

    /**
     * @column(type="integer")
     * @version
     */
    protected $version;