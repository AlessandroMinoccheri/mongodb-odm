<?php
/*
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * This software consists of voluntary contributions made by many individuals
 * and is licensed under the MIT license. For more information, see
 * <http://www.doctrine-project.org>.
 */

namespace Doctrine\ODM\MongoDB\Query;

use Doctrine\ODM\MongoDB\Cursor;
use Doctrine\ODM\MongoDB\DocumentManager;
use Doctrine\ODM\MongoDB\Mapping\ClassMetadata;
use MongoDB\Collection;
use MongoDB\Driver\Cursor as BaseCursor;
use MongoDB\Driver\ReadPreference;
use MongoDB\Operation\FindOneAndUpdate;


/**
 * ODM Query wraps the raw Doctrine MongoDB queries to add additional functionality
 * and to hydrate the raw arrays of data to Doctrine document objects.
 *
 * @since       1.0
 */
class Query
{
    const TYPE_FIND            = 1;
    const TYPE_FIND_AND_UPDATE = 2;
    const TYPE_FIND_AND_REMOVE = 3;
    const TYPE_INSERT          = 4;
    const TYPE_UPDATE          = 5;
    const TYPE_REMOVE          = 6;
    const TYPE_GROUP           = 7;
    const TYPE_MAP_REDUCE      = 8;
    const TYPE_DISTINCT        = 9;
    const TYPE_GEO_NEAR        = 10;
    const TYPE_COUNT           = 11;

    /**
     * @deprecated 1.1 Will be removed for 2.0
     */
    const TYPE_GEO_LOCATION = 10;

    const HINT_REFRESH = 1;
    /** @deprecated */
    const HINT_SLAVE_OKAY = 2;
    const HINT_READ_PREFERENCE = 3;
    const HINT_READ_ONLY = 5;

    /**
     * The DocumentManager instance.
     *
     * @var DocumentManager
     */
    private $dm;

    /**
     * The ClassMetadata instance.
     *
     * @var ClassMetadata
     */
    private $class;

    /**
     * Whether to hydrate results as document class instances.
     *
     * @var boolean
     */
    private $hydrate = true;

    /**
     * Array of primer Closure instances.
     *
     * @var array
     */
    private $primers = array();

    /**
     * Hints for UnitOfWork behavior.
     *
     * @var array
     */
    private $unitOfWorkHints = array();

    /**
     * The Collection instance.
     *
     * @var Collection
     */
    protected $collection;

    /**
     * Query structure generated by the Builder class.
     *
     * @var array
     */
    private $query;

    /**
     * @var Iterator
     */
    private $iterator;

    /**
     * Query options
     *
     * @var array
     */
    private $options;

    /**
     * Constructor.
     *
     * Please note that $requireIndexes was deprecated in 1.2 and will be removed in 2.0
     *
     * @param DocumentManager $dm
     * @param ClassMetadata $class
     * @param Collection $collection
     * @param array $query
     * @param array $options
     * @param boolean $hydrate
     * @param boolean $refresh
     * @param array $primers
     * @param boolean $readOnly
     */
    public function __construct(DocumentManager $dm, ClassMetadata $class, Collection $collection, array $query = array(), array $options = array(), $hydrate = true, $refresh = false, array $primers = array(), $readOnly = false)
    {
        $primers = array_filter($primers);

        if ( ! empty($primers)) {
            $query['eagerCursor'] = true;
        }

        if ( ! empty($query['eagerCursor'])) {
            $query['useIdentifierKeys'] = false;
        }

        switch ($query['type']) {
            case self::TYPE_FIND:
            case self::TYPE_FIND_AND_UPDATE:
            case self::TYPE_FIND_AND_REMOVE:
            case self::TYPE_INSERT:
            case self::TYPE_UPDATE:
            case self::TYPE_REMOVE:
            case self::TYPE_GROUP:
            case self::TYPE_MAP_REDUCE:
            case self::TYPE_DISTINCT:
            case self::TYPE_GEO_NEAR:
            case self::TYPE_COUNT:
                break;

            default:
                throw new \InvalidArgumentException('Invalid query type: ' . $query['type']);
        }

        $this->collection = $collection;
        $this->query      = $query;
        $this->options    = $options;
        $this->dm = $dm;
        $this->class = $class;
        $this->hydrate = $hydrate;
        $this->primers = $primers;

        $this->setReadOnly($readOnly);
        $this->setRefresh($refresh);

        if (isset($query['slaveOkay'])) {
            $this->unitOfWorkHints[self::HINT_SLAVE_OKAY] = $query['slaveOkay'];
        }

        if (isset($query['readPreference'])) {
            $this->unitOfWorkHints[self::HINT_READ_PREFERENCE] = $query['readPreference'];
        }
    }

    public function __clone()
    {
        $this->iterator = null;
    }

    /**
     * Return an array of information about the query structure for debugging.
     *
     * The $name parameter may be used to return a specific key from the
     * internal $query array property. If omitted, the entire array will be
     * returned.
     *
     * @param string $name
     * @return mixed
     */
    public function debug($name = null)
    {
        return $name !== null ? $this->query[$name] : $this->query;
    }

    /**
     * Execute the query and returns the results.
     *
     * @throws \Doctrine\ODM\MongoDB\MongoDBException
     * @return mixed
     */
    public function execute()
    {
        $results = $this->runQuery();

        if ( ! $this->hydrate) {
            return $results;
        }

        if ($results instanceof BaseCursor) {
            $results = $this->makeCursor($results);
        }

        $uow = $this->dm->getUnitOfWork();

        /* A geoNear command returns an ArrayIterator, where each result is an
         * object with "dis" (computed distance) and "obj" (original document)
         * properties. If hydration is enabled, eagerly hydrate these results.
         *
         * Other commands results are not handled, since their results may not
         * resemble documents in the collection.
         */
        if ($this->query['type'] === self::TYPE_GEO_NEAR) {
            foreach ($results as $key => $result) {
                $document = $result['obj'];
                if ($this->class->distance !== null) {
                    $document[$this->class->distance] = $result['dis'];
                }
                $results[$key] = $uow->getOrCreateDocument($this->class->name, $document, $this->unitOfWorkHints);
            }
            $results->reset();
        }

        /* If a single document is returned from a findAndModify command and it
         * includes the identifier field, attempt hydration.
         */
        if (($this->query['type'] === self::TYPE_FIND_AND_UPDATE ||
                $this->query['type'] === self::TYPE_FIND_AND_REMOVE) &&
            is_array($results) && isset($results['_id'])) {

            $results = $uow->getOrCreateDocument($this->class->name, $results, $this->unitOfWorkHints);

            if ( ! empty($this->primers)) {
                $referencePrimer = new ReferencePrimer($this->dm, $uow);

                foreach ($this->primers as $fieldName => $primer) {
                    $primer = is_callable($primer) ? $primer : null;
                    $referencePrimer->primeReferences($this->class, array($results), $fieldName, $this->unitOfWorkHints, $primer);
                }
            }
        }

        return $results;
    }

    /**
     * Gets the ClassMetadata instance.
     *
     * @return ClassMetadata $class
     */
    public function getClass()
    {
        return $this->class;
    }

    /**
     * Gets the DocumentManager instance.
     *
     * @return DocumentManager $dm
     */
    public function getDocumentManager()
    {
        return $this->dm;
    }

    /**
     * Execute the query and return its result, which must be an Iterator.
     *
     * If the query type is not expected to return an Iterator,
     * BadMethodCallException will be thrown before executing the query.
     * Otherwise, the query will be executed and UnexpectedValueException will
     * be thrown if {@link Query::execute()} does not return an Iterator.
     *
     * @see http://php.net/manual/en/iteratoraggregate.getiterator.php
     * @return Iterator
     * @throws \BadMethodCallException if the query type would not return an Iterator
     * @throws \UnexpectedValueException if the query did not return an Iterator
     */
    public function getIterator()
    {
        switch ($this->query['type']) {
            case self::TYPE_FIND:
            case self::TYPE_GROUP:
            case self::TYPE_MAP_REDUCE:
            case self::TYPE_DISTINCT:
            case self::TYPE_GEO_NEAR:
                break;

            default:
                throw new \BadMethodCallException('Iterator would not be returned for query type: ' . $this->query['type']);
        }

        if ($this->iterator === null) {
            $this->iterator = $this->execute();
        }

        return $this->iterator;
    }

    /**
     * Return the query structure.
     *
     * @return array
     */
    public function getQuery()
    {
        return $this->query;
    }

    /**
     * Execute the query and return the first result.
     *
     * @see IteratorAggregate::getSingleResult()
     * @return array|object|null
     */
    public function getSingleResult()
    {
        $clonedQuery = clone $this;
        return $clonedQuery->getIterator()->current();
    }

    /**
     * Return the query type.
     *
     * @return integer
     */
    public function getType()
    {
        return $this->query['type'];
    }

    /**
     * Sets whether or not to hydrate the documents to objects.
     *
     * @param boolean $hydrate
     */
    public function setHydrate($hydrate)
    {
        $this->hydrate = (boolean) $hydrate;
    }

    /**
     * Set whether documents should be registered in UnitOfWork. If document would
     * already be managed it will be left intact and new instance returned.
     * 
     * This option has no effect if hydration is disabled.
     * 
     * @param boolean $readOnly
     */
    public function setReadOnly($readOnly)
    {
        $this->unitOfWorkHints[Query::HINT_READ_ONLY] = (boolean) $readOnly;
    }

    /**
     * Set whether to refresh hydrated documents that are already in the
     * identity map.
     *
     * This option has no effect if hydration is disabled.
     *
     * @param boolean $refresh
     */
    public function setRefresh($refresh)
    {
        $this->unitOfWorkHints[Query::HINT_REFRESH] = (boolean) $refresh;
    }

    /**
     * Execute the query and return its results as an array.
     *
     * @see IteratorAggregate::toArray()
     * @return array
     */
    public function toArray()
    {
        return $this->getIterator()->toArray();
    }

    /**
     * Returns an array containing the specified keys and their values from the
     * query array, provided they exist and are not null.
     *
     * @param string $key,... One or more option keys to be read
     * @return array
     */
    private function getQueryOptions(/* $key, ... */)
    {
        return array_filter(
            array_intersect_key($this->query, array_flip(func_get_args())),
            function($value) { return $value !== null; }
        );
    }

    private function makeCursor(BaseCursor $cursor)
    {
        $cursor = new Cursor($cursor, $this->dm->getUnitOfWork(), $this->class);
        $cursor->hydrate($this->hydrate);
        $cursor->setHints($this->unitOfWorkHints);

        if ( ! empty($this->primers)) {
            $referencePrimer = new ReferencePrimer($this->dm, $this->dm->getUnitOfWork());
            $cursor->enableReferencePriming($this->primers, $referencePrimer);
        }

        return $cursor;
    }

    /**
     * Prepare the Cursor returned by {@link Query::execute()}.
     *
     * This method will wrap the base Cursor with an ODM Cursor or EagerCursor,
     * and set the hydrate option and UnitOfWork hints. This occurs in addition
     * to any preparation done by the base Query class.
     *
     * @param BaseCursor $cursor
     * @return Cursor
     */
    private function prepareCursor(BaseCursor $cursor)
    {
        // Convert the base Cursor into an ODM Cursor
        $cursor = new Cursor($cursor, $this->dm->getUnitOfWork(), $this->class);

        $cursor->hydrate($this->hydrate);
        $cursor->setHints($this->unitOfWorkHints);

        if ( ! empty($this->primers)) {
            $referencePrimer = new ReferencePrimer($this->dm, $this->dm->getUnitOfWork());
            $cursor->enableReferencePriming($this->primers, $referencePrimer);
        }

        return $cursor;
    }

    /**
     * Returns an array with its keys renamed based on the translation map.
     *
     * @param array $options Query options
     * @return array $rename Translation map (from => to) for renaming keys
     */
    private function renameQueryOptions(array $options, array $rename)
    {
        if (empty($options)) {
            return $options;
        }

        return array_combine(
            array_map(
                function($key) use ($rename) { return isset($rename[$key]) ? $rename[$key] : $key; },
                array_keys($options)
            ),
            array_values($options)
        );
    }

    /**
     * Execute the query and return its result.
     *
     * The return value will vary based on the query type. Commands with results
     * (e.g. aggregate, inline mapReduce) may return an ArrayIterator. Other
     * commands and operations may return a status array or a boolean, depending
     * on the driver's write concern. Queries and some mapReduce commands will
     * return a CursorInterface.
     *
     * @return mixed
     */
    public function runQuery()
    {
        $options = $this->options;

        switch ($this->query['type']) {
            case self::TYPE_FIND:
                $queryOptions = $this->getQueryOptions('select', 'sort', 'skip', 'limit', 'readPreference');
                $queryOptions = $this->renameQueryOptions($queryOptions, ['select' => 'projection']);

                $cursor = $this->collection->find(
                    $this->query['query'],
                    $queryOptions
                );

                return $this->prepareCursor($cursor);

            case self::TYPE_FIND_AND_UPDATE:
                $queryOptions = $this->getQueryOptions('select', 'sort', 'upsert');
                $queryOptions = $this->renameQueryOptions($queryOptions, ['select' => 'projection']);
                $queryOptions['returnDocument'] = ($this->query['new'] ?? false) ? FindOneAndUpdate::RETURN_DOCUMENT_AFTER : FindOneAndUpdate::RETURN_DOCUMENT_BEFORE;

                $closure = function(Collection $collection) use ($options, $queryOptions) {
                    return $collection->findOneAndUpdate(
                        $this->query['query'],
                        $this->query['newObj'],
                        array_merge($options, $queryOptions)
                    );
                };

                return $this->withPrimaryReadPreference($this->collection, $closure);

            case self::TYPE_FIND_AND_REMOVE:
                $queryOptions = $this->getQueryOptions('select', 'sort');
                $queryOptions = $this->renameQueryOptions($queryOptions, ['select' => 'projection']);

                $closure = function(Collection $collection) use ($options, $queryOptions) {
                    return $collection->findOneAndDelete(
                        $this->query['query'],
                        array_merge($options, $queryOptions)
                    );
                };

                return $this->withPrimaryReadPreference($this->collection, $closure);

            case self::TYPE_INSERT:
                return $this->collection->insertOne($this->query['newObj'], $options);

            case self::TYPE_UPDATE:
                if ($this->query['multiple'] ?? false) {
                    return $this->collection->updateMany(
                        $this->query['query'],
                        $this->query['newObj'],
                        array_merge($options, $this->getQueryOptions('upsert'))
                    );
                } else {
                    return $this->collection->updateOne(
                        $this->query['query'],
                        $this->query['newObj'],
                        array_merge($options, $this->getQueryOptions('upsert'))
                    );
                }

            case self::TYPE_REMOVE:
                return $this->collection->deleteMany($this->query['query'], $options);

            case self::TYPE_GROUP:
                // TODO: Handle running commands
                throw new \Exception('Not implemented');
                if ( ! empty($this->query['query'])) {
                    $options['cond'] = $this->query['query'];
                }

                $collection = $this->collection;
                $query = $this->query;

                $closure = function(Collection $collection) use ($query, $options) {
                    return $collection->group(
                        $query['group']['keys'],
                        $query['group']['initial'],
                        $query['group']['reduce'],
                        array_merge($options, $query['group']['options'])
                    );
                };

                return $this->withReadPreference($collection, $closure);

            case self::TYPE_MAP_REDUCE:
                // TODO: Handle running commands
                throw new \Exception('Not implemented');
                if (isset($this->query['limit'])) {
                    $options['limit'] = $this->query['limit'];
                }

                $collection = $this->collection;
                $query = $this->query;

                $closure = function(Collection $collection) use ($query, $options) {
                    return $collection->mapReduce(
                        $query['mapReduce']['map'],
                        $query['mapReduce']['reduce'],
                        $query['mapReduce']['out'],
                        $query['query'],
                        array_merge($options, $query['mapReduce']['options'])
                    );
                };

                // Force a primary read preference if mapReduce is a write operation
                $results = ((array) $this->query['mapReduce']['out'] !== ['inline' => true])
                    ? $this->withPrimaryReadPreference($collection, $closure)
                    : $this->withReadPreference($collection, $closure);

                return ($results instanceof Cursor) ? $this->prepareCursor($results) : $results;

            case self::TYPE_DISTINCT:
                $collection = $this->collection;
                $query = $this->query;

                return $collection->distinct(
                    $query['distinct'],
                    $query['query'],
                    array_merge($options, $this->getQueryOptions('readPreference'))
                );

            case self::TYPE_GEO_NEAR:
                // TODO: Handle running commands
                throw new \Exception('Not implemented');
                if (isset($this->query['limit'])) {
                    $options['num'] = $this->query['limit'];
                }

                $collection = $this->collection;
                $query = $this->query;

                $closure = function(Collection $collection) use ($query, $options) {
                    return $collection->near(
                        $query['geoNear']['near'],
                        $query['query'],
                        array_merge($options, $query['geoNear']['options'])
                    );
                };

                return $this->withReadPreference($collection, $closure);

            case self::TYPE_COUNT:
                $collection = $this->collection;
                $query = $this->query;

                return $collection->count(
                    $query['query'],
                    array_merge($options, $this->getQueryOptions('hint', 'limit', 'skip', 'readPreference'))
                );
        }
    }

    /**
     * Executes a closure with a temporary primary read preference on a database
     * or collection.
     *
     * @param Database|Collection $object
     * @param \Closure            $closure
     * @return mixed
     */
    private function withPrimaryReadPreference($object, \Closure $closure)
    {
        $this->query['readPreference'] = new ReadPreference(ReadPreference::RP_PRIMARY);

        return $this->withReadPreference($object, $closure);
    }

    /**
     * Executes a closure with a temporary read preference on a database or
     * collection.
     *
     * @param Database|Collection $object
     * @param \Closure            $closure
     * @return mixed
     */
    private function withReadPreference($object, \Closure $closure)
    {
        if ( ! isset($this->query['readPreference'])) {
            return $closure();
        }

        return $closure($object->withOptions(['readPreference' => $this->query['readPreference']]));
    }
}
