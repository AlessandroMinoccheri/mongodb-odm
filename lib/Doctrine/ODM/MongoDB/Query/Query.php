<?php

declare(strict_types=1);

namespace Doctrine\ODM\MongoDB\Query;

use Doctrine\ODM\MongoDB\DocumentManager;
use Doctrine\ODM\MongoDB\Iterator\CachingIterator;
use Doctrine\ODM\MongoDB\Iterator\HydratingIterator;
use Doctrine\ODM\MongoDB\Iterator\Iterator;
use Doctrine\ODM\MongoDB\Iterator\PrimingIterator;
use Doctrine\ODM\MongoDB\Mapping\ClassMetadata;
use Doctrine\ODM\MongoDB\MongoDBException;
use MongoDB\Collection;
use MongoDB\Driver\Cursor;
use MongoDB\Operation\FindOneAndUpdate;
use function array_combine;
use function array_filter;
use function array_flip;
use function array_intersect_key;
use function array_keys;
use function array_map;
use function array_merge;
use function array_values;
use function is_array;
use function is_callable;

/**
 * ODM Query wraps the raw Doctrine MongoDB queries to add additional functionality
 * and to hydrate the raw arrays of data to Doctrine document objects.
 *
 */
class Query implements \IteratorAggregate
{
    public const TYPE_FIND            = 1;
    public const TYPE_FIND_AND_UPDATE = 2;
    public const TYPE_FIND_AND_REMOVE = 3;
    public const TYPE_INSERT          = 4;
    public const TYPE_UPDATE          = 5;
    public const TYPE_REMOVE          = 6;
    public const TYPE_GROUP           = 7;
    public const TYPE_MAP_REDUCE      = 8;
    public const TYPE_DISTINCT        = 9;
    public const TYPE_COUNT           = 11;

    /**
     * @deprecated 1.1 Will be removed for 2.0
     */
    public const TYPE_GEO_LOCATION = 10;

    public const HINT_REFRESH = 1;
    // 2 was used for HINT_SLAVE_OKAY, which was removed in 2.0
    public const HINT_READ_PREFERENCE = 3;
    public const HINT_READ_ONLY = 5;

    /**
     * The DocumentManager instance.
     *
     * @var DocumentManager
     */
    private $dm;

    /**
     * The ClassMetadata instance.
     *
     * @var ClassMetadata
     */
    private $class;

    /**
     * Whether to hydrate results as document class instances.
     *
     * @var bool
     */
    private $hydrate = true;

    /**
     * Array of primer Closure instances.
     *
     * @var array
     */
    private $primers = [];

    /**
     * Hints for UnitOfWork behavior.
     *
     * @var array
     */
    private $unitOfWorkHints = [];

    /**
     * The Collection instance.
     *
     * @var Collection
     */
    protected $collection;

    /**
     * Query structure generated by the Builder class.
     *
     * @var array
     */
    private $query;

    /**
     * @var Iterator
     */
    private $iterator;

    /**
     * Query options
     *
     * @var array
     */
    private $options;

    /**
     *
     *
     * Please note that $requireIndexes was deprecated in 1.2 and will be removed in 2.0
     *
     * @param array $query
     * @param array $options
     * @param bool  $hydrate
     * @param bool  $refresh
     * @param array $primers
     * @param bool  $readOnly
     */
    public function __construct(DocumentManager $dm, ClassMetadata $class, Collection $collection, array $query = [], array $options = [], $hydrate = true, $refresh = false, array $primers = [], $readOnly = false)
    {
        $primers = array_filter($primers);

        if (! empty($primers)) {
            $query['eagerCursor'] = true;
        }

        if (! empty($query['eagerCursor'])) {
            $query['useIdentifierKeys'] = false;
        }

        switch ($query['type']) {
            case self::TYPE_FIND:
            case self::TYPE_FIND_AND_UPDATE:
            case self::TYPE_FIND_AND_REMOVE:
            case self::TYPE_INSERT:
            case self::TYPE_UPDATE:
            case self::TYPE_REMOVE:
            case self::TYPE_GROUP:
            case self::TYPE_MAP_REDUCE:
            case self::TYPE_DISTINCT:
            case self::TYPE_COUNT:
                break;

            default:
                throw new \InvalidArgumentException('Invalid query type: ' . $query['type']);
        }

        $this->collection = $collection;
        $this->query      = $query;
        $this->options    = $options;
        $this->dm = $dm;
        $this->class = $class;
        $this->hydrate = $hydrate;
        $this->primers = $primers;

        $this->setReadOnly($readOnly);
        $this->setRefresh($refresh);

        if (isset($query['readPreference'])) {
            $this->unitOfWorkHints[self::HINT_READ_PREFERENCE] = $query['readPreference'];
        }
    }

    public function __clone()
    {
        $this->iterator = null;
    }

    /**
     * Return an array of information about the query structure for debugging.
     *
     * The $name parameter may be used to return a specific key from the
     * internal $query array property. If omitted, the entire array will be
     * returned.
     *
     * @param string $name
     * @return mixed
     */
    public function debug($name = null)
    {
        return $name !== null ? $this->query[$name] : $this->query;
    }

    /**
     * Execute the query and returns the results.
     *
     * @throws MongoDBException
     * @return Iterator|int|string|array
     */
    public function execute()
    {
        $results = $this->runQuery();

        if (! $this->hydrate) {
            return $results;
        }

        if ($results instanceof Cursor) {
            $results = $this->makeIterator($results);
        }

        $uow = $this->dm->getUnitOfWork();

        /* If a single document is returned from a findAndModify command and it
         * includes the identifier field, attempt hydration.
         */
        if (($this->query['type'] === self::TYPE_FIND_AND_UPDATE ||
                $this->query['type'] === self::TYPE_FIND_AND_REMOVE) &&
            is_array($results) && isset($results['_id'])) {
            $results = $uow->getOrCreateDocument($this->class->name, $results, $this->unitOfWorkHints);

            if (! empty($this->primers)) {
                $referencePrimer = new ReferencePrimer($this->dm, $uow);

                foreach ($this->primers as $fieldName => $primer) {
                    $primer = is_callable($primer) ? $primer : null;
                    $referencePrimer->primeReferences($this->class, [$results], $fieldName, $this->unitOfWorkHints, $primer);
                }
            }
        }

        return $results;
    }

    /**
     * Gets the ClassMetadata instance.
     *
     * @return ClassMetadata $class
     */
    public function getClass()
    {
        return $this->class;
    }

    /**
     * Gets the DocumentManager instance.
     *
     * @return DocumentManager $dm
     */
    public function getDocumentManager()
    {
        return $this->dm;
    }

    /**
     * Execute the query and return its result, which must be an Iterator.
     *
     * If the query type is not expected to return an Iterator,
     * BadMethodCallException will be thrown before executing the query.
     * Otherwise, the query will be executed and UnexpectedValueException will
     * be thrown if {@link Query::execute()} does not return an Iterator.
     *
     * @see http://php.net/manual/en/iteratoraggregate.getiterator.php
     * @return Iterator
     * @throws \BadMethodCallException if the query type would not return an Iterator
     * @throws \UnexpectedValueException if the query did not return an Iterator
     */
    public function getIterator()
    {
        switch ($this->query['type']) {
            case self::TYPE_FIND:
            case self::TYPE_GROUP:
            case self::TYPE_MAP_REDUCE:
            case self::TYPE_DISTINCT:
                break;

            default:
                throw new \BadMethodCallException('Iterator would not be returned for query type: ' . $this->query['type']);
        }

        if ($this->iterator === null) {
            $this->iterator = $this->execute();
        }

        return $this->iterator;
    }

    /**
     * Return the query structure.
     *
     * @return array
     */
    public function getQuery()
    {
        return $this->query;
    }

    /**
     * Execute the query and return the first result.
     *
     * @return array|object|null
     */
    public function getSingleResult()
    {
        $clonedQuery = clone $this;
        $clonedQuery->query['limit'] = 1;
        return $clonedQuery->getIterator()->current() ?: null;
    }

    /**
     * Return the query type.
     *
     * @return int
     */
    public function getType()
    {
        return $this->query['type'];
    }

    /**
     * Sets whether or not to hydrate the documents to objects.
     *
     * @param bool $hydrate
     */
    public function setHydrate($hydrate)
    {
        $this->hydrate = (bool) $hydrate;
    }

    /**
     * Set whether documents should be registered in UnitOfWork. If document would
     * already be managed it will be left intact and new instance returned.
     *
     * This option has no effect if hydration is disabled.
     *
     * @param bool $readOnly
     */
    public function setReadOnly($readOnly)
    {
        $this->unitOfWorkHints[self::HINT_READ_ONLY] = (bool) $readOnly;
    }

    /**
     * Set whether to refresh hydrated documents that are already in the
     * identity map.
     *
     * This option has no effect if hydration is disabled.
     *
     * @param bool $refresh
     */
    public function setRefresh($refresh)
    {
        $this->unitOfWorkHints[self::HINT_REFRESH] = (bool) $refresh;
    }

    /**
     * Execute the query and return its results as an array.
     *
     * @see IteratorAggregate::toArray()
     * @return array
     */
    public function toArray()
    {
        return $this->getIterator()->toArray();
    }

    /**
     * Returns an array containing the specified keys and their values from the
     * query array, provided they exist and are not null.
     *
     * @param string ...$keys One or more option keys to be read
     * @return array
     */
    private function getQueryOptions(string ...$keys)
    {
        return array_filter(
            array_intersect_key($this->query, array_flip($keys)),
            function ($value) {
                return $value !== null;
            }
        );
    }

    private function makeIterator(Cursor $cursor): Iterator
    {
        if ($this->hydrate && $this->class) {
            $cursor = new HydratingIterator($cursor, $this->dm->getUnitOfWork(), $this->class, $this->unitOfWorkHints);
        }

        $cursor = new CachingIterator($cursor);

        if (! empty($this->primers)) {
            $referencePrimer = new ReferencePrimer($this->dm, $this->dm->getUnitOfWork());
            $cursor = new PrimingIterator($cursor, $this->class, $referencePrimer, $this->primers, $this->unitOfWorkHints);
        }

        return $cursor;
    }

    /**
     * Returns an array with its keys renamed based on the translation map.
     *
     * @param array $options Query options
     * @return array $rename Translation map (from => to) for renaming keys
     */
    private function renameQueryOptions(array $options, array $rename)
    {
        if (empty($options)) {
            return $options;
        }

        return array_combine(
            array_map(
                function ($key) use ($rename) {
                    return $rename[$key] ?? $key;
                },
                array_keys($options)
            ),
            array_values($options)
        );
    }

    /**
     * Execute the query and return its result.
     *
     * The return value will vary based on the query type. Commands with results
     * (e.g. aggregate, inline mapReduce) may return an ArrayIterator. Other
     * commands and operations may return a status array or a boolean, depending
     * on the driver's write concern. Queries and some mapReduce commands will
     * return an Iterator.
     *
     * @return Iterator|string|int|array
     */
    public function runQuery()
    {
        $options = $this->options;

        switch ($this->query['type']) {
            case self::TYPE_FIND:
                $queryOptions = $this->getQueryOptions('select', 'sort', 'skip', 'limit', 'readPreference');
                $queryOptions = $this->renameQueryOptions($queryOptions, ['select' => 'projection']);

                $cursor = $this->collection->find(
                    $this->query['query'],
                    $queryOptions
                );

                return $this->makeIterator($cursor);

            case self::TYPE_FIND_AND_UPDATE:
                $queryOptions = $this->getQueryOptions('select', 'sort', 'upsert');
                $queryOptions = $this->renameQueryOptions($queryOptions, ['select' => 'projection']);
                $queryOptions['returnDocument'] = ($this->query['new'] ?? false) ? FindOneAndUpdate::RETURN_DOCUMENT_AFTER : FindOneAndUpdate::RETURN_DOCUMENT_BEFORE;

                return $this->collection->findOneAndUpdate(
                    $this->query['query'],
                    $this->query['newObj'],
                    array_merge($options, $queryOptions)
                );

            case self::TYPE_FIND_AND_REMOVE:
                $queryOptions = $this->getQueryOptions('select', 'sort');
                $queryOptions = $this->renameQueryOptions($queryOptions, ['select' => 'projection']);

                return $this->collection->findOneAndDelete(
                    $this->query['query'],
                    array_merge($options, $queryOptions)
                );

            case self::TYPE_INSERT:
                return $this->collection->insertOne($this->query['newObj'], $options);

            case self::TYPE_UPDATE:
                if ($this->query['multiple'] ?? false) {
                    return $this->collection->updateMany(
                        $this->query['query'],
                        $this->query['newObj'],
                        array_merge($options, $this->getQueryOptions('upsert'))
                    );
                }

                return $this->collection->updateOne(
                    $this->query['query'],
                    $this->query['newObj'],
                    array_merge($options, $this->getQueryOptions('upsert'))
                );

            case self::TYPE_REMOVE:
                return $this->collection->deleteMany($this->query['query'], $options);

            case self::TYPE_DISTINCT:
                $collection = $this->collection;
                $query = $this->query;

                return $collection->distinct(
                    $query['distinct'],
                    $query['query'],
                    array_merge($options, $this->getQueryOptions('readPreference'))
                );

            case self::TYPE_COUNT:
                $collection = $this->collection;
                $query = $this->query;

                return $collection->count(
                    $query['query'],
                    array_merge($options, $this->getQueryOptions('hint', 'limit', 'skip', 'readPreference'))
                );
        }
    }
}
